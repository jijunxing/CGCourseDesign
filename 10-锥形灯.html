<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>锥形灯</title>
  <style>
    body {
      margin: 0;
      overflow: hidden
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { createProgram, imgPromise } from './lv/Utils.js';
    import { mainShaders, glassShaders, emissiveShaders } from './lv/shaders.js';
    import {
      Matrix4, PerspectiveCamera, Vector3
    } from 'https://unpkg.com/three/build/three.module.js';
    import OrbitControls from './lv/OrbitControls.js'
    import Scene3D from './lv/Scene3D.js'
    import { Light } from './lv/Light.js'
    import Sphere from './lv/Sphere.js'
    import Room from './lv/Room.js'
    import Box from './lv/Box.js'
    import Torus from './lv/Torus.js'
    import { gouraudShading } from './lv/ShadingFrequency.js'
    import Mat from './lv/Mat.js'
    import Geo from './lv/Geo.js'
    import Obj3D from './lv/Obj3D.js'
    import Cone from './lv/Cone.js'
    import Cylinder from './lv/Cylinder.js'
    import HemiSphere from './lv/HemiSphere.js'

    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let gl = canvas.getContext('webgl');
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // 目标点
    const target = new Vector3(0, 6, -10)
    //视点
    const eye = new Vector3(0, 6, 0)
    const [fov, aspect, near, far] = [
      45, canvas.width / canvas.height,
      0.1, 100
    ]
    // 透视相机
    const camera = new PerspectiveCamera(fov, aspect, near, far)
    camera.position.copy(eye)
    // 轨道控制器
    const orbit = new OrbitControls({ 
      camera, 
      target, 
      dom: canvas,
      enablePan: true,      // 启用平移
      rotateDir: 'xy',      // 允许在xy方向旋转
      enableZoom: true,
      minZoom: 0.1,
      maxZoom: 10,
      enableDamping: true,
      dampingFactor: 0.05,
      rotateSpeed: 1.0,
      panSpeed: 1.0,
      zoomSpeed: 1.0
    })

    // 添加鼠标事件监听
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      orbit.pointerdown(e);
    });
    canvas.addEventListener('pointermove', (e) => {
      e.preventDefault();
      orbit.pointermove(e);
    });
    canvas.addEventListener('pointerup', (e) => {
      e.preventDefault();
      orbit.pointerup();
    });
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      orbit.wheel(e);
    });

    // 键盘控制
    const moveSpeed = 0.3;
    const keysPressed = new Set();
    
    window.addEventListener('keydown', (e) => {
      keysPressed.add(e.key.toLowerCase());
    });
    
    window.addEventListener('keyup', (e) => {
      keysPressed.delete(e.key.toLowerCase());
    });
    
    // 相机移动函数
    function updateCameraPosition() {
      const { position } = camera;
      // 获取相机到目标点的方向作为前进方向
      const forward = target.clone().sub(position).normalize();
      // 计算右方向
      const right = forward.clone().cross(new Vector3(0, 1, 0)).normalize();
      
      let moved = false;
      // 前后移动
      if (keysPressed.has('w')) {
        const movement = forward.clone().multiplyScalar(moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      if (keysPressed.has('s')) {
        const movement = forward.clone().multiplyScalar(-moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      
      // 左右移动
      if (keysPressed.has('a')) {
        const movement = right.clone().multiplyScalar(-moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      if (keysPressed.has('d')) {
        const movement = right.clone().multiplyScalar(moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      
      // 上下移动
      if (keysPressed.has('q')) {
        position.y += moveSpeed;
        target.y += moveSpeed;
        moved = true;
      }
      if (keysPressed.has('e')) {
        position.y -= moveSpeed;
        target.y -= moveSpeed;
        moved = true;
      }
      
      if (moved) {
        orbit.update();
      }
    }

    // 定义光源
    let lights = [
      // 主光源 - 顶部中央
      new Light(
        new Vector3(0, 9.5, 0),
        [800, 800, 800]  // 增加主光源强度
      ),
      // 前方补光
      new Light(
        new Vector3(0, 8, -9.5),
        [400, 400, 400]  // 增加补光强度
      ),
      // 左侧暖色补光
      new Light(
        new Vector3(-9.5, 8, 0),
        [600, 500, 400]  // 增加暖色调光源强度
      ),
      // 右侧冷色补光
      new Light(
        new Vector3(9.5, 8, 0),
        [400, 500, 600]  // 增加冷色调光源强度
      )
    ]
    
    // 光照数据
    const lightData = {
      u_LightPositions: {
        value: lights.map(light => [...light.position]).flat(),
        type: 'uniform3fv',
      },
      u_LightColors: {
        value: lights.map(light => [...light.color]).flat(),
        type: 'uniform3fv',
      }
    }
    // 材质数据
    const matData = {
      u_Kd: {
        value: [0.9, 0.9, 0.9],
        type: 'uniform3fv',
      },
      u_Ks: {
        value: [0.4, 0.4, 0.4],
        type: 'uniform3fv',
      },
      u_Ka: {
        value: [0.4, 0.4, 0.4],
        type: 'uniform3fv',
      },
    }
    // 相机数据
    const cameraData = {
      u_PvMatrix: {
        value: orbit.getPvMatrix().elements,
        type: 'uniformMatrix4fv',
      },
      u_Eye: {
        value: Object.values(camera.position),
        type: 'uniform3fv',
      },
    }

    // 景
    const scene = new Scene3D({ gl })

    // 等待景初始化完成后再创建对象
    async function initScene() {
      // 检查WebGL上下文
      if (!gl) {
        console.error('Unable to initialize WebGL. Your browser may not support it.');
        return;
      }

      // 等待场景准备就绪
      await new Promise(resolve => {
        const checkReady = () => {
          if (scene.ready) {
            resolve();
          } else {
            setTimeout(checkReady, 100);
          }
        };
        checkReady();
      });

      // 为每个光源创建可视化球体
      lights.forEach(light => {
        const visualizer = light.createVisualizer(scene);
        if (visualizer) {
          scene.add(visualizer);
        }
      });

      // 创建光照数据
      const lightPositions = [];
      const lightColors = [];
      lights.forEach(light => {
        lightPositions.push(...light.position);
        lightColors.push(...light.color.map(x => x/800));
      });

      // 基础光照数据
      const lightData = {
        u_LightPositions: {
          value: lightPositions,
          type: 'uniform3fv'
        },
        u_LightColors: {
          value: lightColors,
          type: 'uniform3fv'
        }
      };

      // 相机数据
      const cameraData = {
        u_Eye: {
          value: Object.values(camera.position),
          type: 'uniform3fv'
        },
        u_PvMatrix: {
          value: orbit.getPvMatrix().elements,
          type: 'uniformMatrix4fv'
        }
      };

      // 基础材质数据
      const matData = {
        u_ModelMatrix: {
          value: new Matrix4().elements,
          type: 'uniformMatrix4fv'
        }
      };

      // 基础材质
      const basicMaterial = {
        program: 'Main',
        programName: 'Main',
        data: {
          ...matData,
          ...lightData,
          ...cameraData
        }
      };

      // 创建房间
      const room = new Room(20, 12, 20)
      scene.add(new Obj3D({
        geo: new Geo({
          data: {
            a_Position: {
              array: new Float32Array(room.vertices),
              size: 3
            },
            a_Normal: {
              array: new Float32Array(room.normals),
              size: 3
            },
            a_TexCoord: {
              array: new Float32Array(room.texCoords),
              size: 2
            },
            a_TextureType: {
              array: new Float32Array(room.textureTypes),
              size: 1
            }
          },
          index: {
            array: new Uint16Array(room.indexes)
          }
        }),
        mat: new Mat({
          program: 'Main',
          programName: 'Main',
          data: {
            ...basicMaterial.data,
            u_ModelMatrix: {
              value: new Matrix4().elements,
              type: 'uniformMatrix4fv'
            },
            u_WallTex: {
              value: 0,
              type: 'uniform1i'
            },
            u_FloorTex: {
              value: 1,
              type: 'uniform1i'
            }
          },
          mode: 'TRIANGLES'
        })
      }))

      // 创建球
      const spheres = [
        { position: [-4, 0.8, -4], color: [0.8, 0.3, 0.3] },
        { position: [0, 0.8, 0], color: [0.3, 0.8, 0.3] },
        { position: [4, 0.8, 4], color: [0.3, 0.3, 0.8] }
      ]

      spheres.forEach(({ position, color }) => {
        const sphere = new Sphere(0.8, 24, 24)
        scene.add(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(sphere.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(sphere.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(sphere.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4().setPosition(...position).elements,
                type: 'uniformMatrix4fv'
              },
              u_Color: {
                value: color,
                type: 'uniform3fv'
              }
            },
            mode: 'TRIANGLES'
          })
        }))
      })

      // 添加光源可视化
      lights.forEach(light => {
        scene.add(light.createVisualizer({
          gl,
          camera: {
            getPvMatrix: () => orbit.getPvMatrix()
          }
        }));
      })

      // 加载纹理
      const [wallTex, floorTex] = await Promise.all([
          imgPromise('./textures/wall.jpg'),
          imgPromise('./textures/floor.jpg')
      ]);

      // 设置纹理参数
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
      
      // 创建墙壁纹理
      const wallTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, wallTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, wallTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      
      // 创建地板纹理
      const floorTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, floorTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, floorTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

      // 设置纹理
      const textureUniforms = {
          u_WallTex: {
              value: 0,
              type: 'uniform1i'
          },
          u_FloorTex: {
              value: 1,
              type: 'uniform1i'
          }
      };
      
      // 更新基础材质数据
      basicMaterial.data = {
          ...basicMaterial.data,
          ...textureUniforms
      };
      
      // 创建玻璃球
      const glassSphere = new Sphere(0.8, 32, 32)
      scene.add(new Obj3D({
        geo: new Geo({
          data: {
            a_Position: {
              array: new Float32Array(glassSphere.vertices),
              size: 3
            },
            a_Normal: {
              array: new Float32Array(glassSphere.normals),
              size: 3
            }
          },
          index: {
            array: new Uint16Array(glassSphere.indexes)
          }
        }),
        mat: new Mat({
          program: 'Glass',
          programName: 'Glass',
          data: {
            ...basicMaterial.data,
            u_ModelMatrix: {
              value: new Matrix4().setPosition(0, 0.8, -4).elements,
              type: 'uniformMatrix4fv'
            },
            u_NormalMatrix: {
              value: new Matrix4()
                .makeTranslation(0, 0.8, -4)
                .invert()
                .transpose()
                .elements,
              type: 'uniformMatrix4fv'
            }
          }
        })
      }))

      // 添加一些装饰性物体
      const decorations = [
        // 金属环
        { 
          geometry: new Torus(0.5, 0.2, 32, 32),
          position: [2, 1.2, 2],
          rotation: [Math.PI/4, 0, Math.PI/6],
          material: {
            metallic: 0.9,    // 稍微降低金属度
            roughness: 0.3,   // 增加一点粗糙度
            color: [0.98, 0.8, 0.6] // 更亮的玫瑰金色
          }
        },
        // 木制立方体
        {
          geometry: new Box(0.8, 0.8, 0.8),
          position: [-2, 0.4, 3],
          rotation: [0, Math.PI/6, 0],
          material: {
            metallic: 0.1,    // 增加一点金属感
            roughness: 0.7,   // 降低粗糙度
            color: [0.8, 0.4, 0.2] // 更亮的木色
          }
        },
        // 大理石球
        {
          geometry: new Sphere(0.6, 32, 32),
          position: [3, 0.6, -2],
          material: {
            metallic: 0.2,    // 增加一点金属感
            roughness: 0.1,   // 保持光滑
            color: [1.0, 1.0, 1.0] // 纯白色
          }
        }
      ]

      // 添加装饰物
      decorations.forEach(({ geometry, position, rotation = [0,0,0], material }) => {
        scene.add(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(geometry.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(geometry.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(geometry.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...position)
                  .multiply(
                    new Matrix4().makeRotationX(rotation[0])
                      .multiply(new Matrix4().makeRotationY(rotation[1]))
                      .multiply(new Matrix4().makeRotationZ(rotation[2]))
                  )
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: material.metallic,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: material.roughness,
                type: 'uniform1f'
              },
              u_Color: {
                value: material.color,
                type: 'uniform3fv'
              }
            }
          })
        }))
      })

      // 创建吊灯
      function createCeilingLamp(position, color) {
        const lampGroup = [];
        
        // 灯罩（圆锥体）
        const lampShade = new Cone(0.6, 0.2, 1.2, 32);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lampShade.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(lampShade.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lampShade.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...position)
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.1,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.9, 0.9, 0.9],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 发光体
        const lightBulb = new Sphere(0.2, 16, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lightBulb.vertices),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lightBulb.indexes)
            }
          }),
          mat: new Mat({
            program: 'Emissive',
            programName: 'Emissive',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(position[0], position[1] - 0.2, position[2])
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_EmissiveColor: {
                value: color.map(c => c/800),
                type: 'uniform3fv'
              },
              u_Intensity: {
                value: 2.0,
                type: 'uniform1f'
              }
            }
          })
        }));

        return lampGroup;
      }

      // 创建壁灯
      function createWallLamp(position, rotation, color) {
        const lampGroup = [];
        
        // 灯臂
        const arm = new Cylinder(0.05, 0.05, 0.8, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(arm.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(arm.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(arm.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...position)
                  .multiply(
                    new Matrix4().makeRotationX(rotation[0])
                      .multiply(new Matrix4().makeRotationY(rotation[1]))
                      .multiply(new Matrix4().makeRotationZ(rotation[2]))
                  )
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.2,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.8, 0.8, 0.8],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 灯罩（半球形）
        const shade = new HemiSphere(0.3, 16, 16);
        const shadePosition = [
          position[0] + Math.sin(rotation[1]) * 0.8,
          position[1],
          position[2] + Math.cos(rotation[1]) * 0.8
        ];
        
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(shade.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(shade.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(shade.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...shadePosition)
                  .multiply(
                    new Matrix4().makeRotationY(rotation[1] + Math.PI/2)
                  )
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.1,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.9, 0.9, 0.9],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 发光体
        const lightBulb = new Sphere(0.15, 16, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lightBulb.vertices),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lightBulb.indexes)
            }
          }),
          mat: new Mat({
            program: 'Emissive',
            programName: 'Emissive',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...shadePosition)
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_EmissiveColor: {
                value: color.map(c => c/800),
                type: 'uniform3fv'
              },
              u_Intensity: {
                value: 1.5,
                type: 'uniform1f'
              }
            }
          })
        }));

        return lampGroup;
      }

      // 创建并添加灯具
      const lamps = [
        // 中央吊灯
        ...createCeilingLamp([0, 9.5, 0], [800, 800, 800]),
        
        // 壁灯
        ...createWallLamp([-9.5, 8, 0], [0, Math.PI/2, 0], [600, 500, 400]),
        ...createWallLamp([9.5, 8, 0], [0, -Math.PI/2, 0], [400, 500, 600]),
        ...createWallLamp([0, 8, -9.5], [0, 0, 0], [400, 400, 400])
      ];

      lamps.forEach(lamp => scene.add(lamp));

      // 开始动画
      animate();
    }

    // 启动场景初始化
    initScene().catch(error => {
      console.error('Scene initialization failed:', error);
    });

    // 渲染循环
    function animate() {
        if (!scene.ready) {
            requestAnimationFrame(animate);
            return;
        }
        // 更新时间
        time += 0.016;
        
        // 更新相机位置
        updateCameraPosition();
        
        // 始终更新轨道控制器
        orbit.update();
        
        // 更新动态光源位置
        lights.forEach((light, index) => {
            const angle = time * lightSpeed + (index * Math.PI / 2);
            light.position.x = Math.cos(angle) * lightRadius;
            light.position.z = Math.sin(angle) * lightRadius;
        });
        
        // 更新光照数据
        const lightPositions = [];
        const lightColors = [];
        lights.forEach(light => {
            lightPositions.push(...light.position);
            lightColors.push(...light.color.map(x => x/800));
        });
        
        // 更新场景中所有对象的材质数据
        scene.children.forEach(obj => {
            if (obj.mat) {
                const data = {
                    u_PvMatrix: {
                        value: orbit.getPvMatrix().elements,
                        type: 'uniformMatrix4fv'
                    },
                    u_Eye: {
                        value: Object.values(camera.position),
                        type: 'uniform3fv'
                    },
                    u_LightPositions: {
                        value: lightPositions,
                        type: 'uniform3fv'
                    },
                    u_LightColors: {
                        value: lightColors,
                        type: 'uniform3fv'
                    }
                };

                // 如果是玻璃材质，更新法线矩阵
                if (obj.mat.programName === 'Glass') {
                    const modelMatrix = new Matrix4().fromArray(obj.mat.data.u_ModelMatrix.value);
                    data.u_NormalMatrix = {
                        value: new Matrix4()
                          .copy(modelMatrix)
                          .invert()
                          .transpose()
                          .elements,
                        type: 'uniformMatrix4fv'
                    };
                }

                Object.assign(obj.mat.data, data);
            }
        });
        
        // 清除冲区
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        scene.draw();
        
        requestAnimationFrame(animate);
    }

    // 加动画相关变量
    let time = 0;
    const lightSpeed = 0.005;
    const lightRadius = 2;

    // 在文件开头添加这些矩阵对象
    const tempMatrix4 = new Matrix4();
    const normalMatrix = new Matrix4();
  </script>
</body>

</html>