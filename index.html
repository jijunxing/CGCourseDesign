<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>CG课程设计</title>
  <style>
    body {
      margin: 0;
      overflow: hidden
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { createProgram, imgPromise } from './lv/Utils.js';
    import { mainShaders, glassShaders, emissiveShaders } from './lv/shaders.js';
    import {
      Matrix4, PerspectiveCamera, Vector3, OrthographicCamera
    } from 'https://unpkg.com/three/build/three.module.js';
    import OrbitControls from './lv/OrbitControls.js'
    import Scene3D from './lv/Scene3D.js'
    import { Light } from './lv/Light.js'
    import Sphere from './lv/Sphere.js'
    import Room from './lv/Room.js'
    import Box from './lv/Box.js'
    import Torus from './lv/Torus.js'
    import { gouraudShading } from './lv/ShadingFrequency.js'
    import Mat from './lv/Mat.js'
    import Geo from './lv/Geo.js'
    import Obj3D from './lv/Obj3D.js'
    import Cone from './lv/Cone.js'
    import Cylinder from './lv/Cylinder.js'
    import HemiSphere from './lv/HemiSphere.js'

    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let gl = canvas.getContext('webgl');
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // 加动画相关变量
    let time = 0;
    const lightSpeed = 0.005;
    const lightRadius = 2;
    // 存储所有需要动画的物体
    const animatedObjects = [];

    // 在文件开头添加这些矩阵对象
    const tempMatrix4 = new Matrix4();
    const normalMatrix = new Matrix4();

    // 目标点
    const target = new Vector3(0, 6, -10)
    //视点
    const eye = new Vector3(0, 6, 0)
    const [fov, aspect, near, far] = [
      45, canvas.width / canvas.height,
      0.1, 100
    ]
    // 透视相机
    const camera = new PerspectiveCamera(fov, aspect, near, far)
    camera.position.copy(eye)
    // 轨道控制器
    const orbit = new OrbitControls({ 
      camera, 
      target, 
      dom: canvas,
      enablePan: true,      // 启用平移
      rotateDir: 'xy',      // 允许在xy方向旋转
      enableZoom: true,
      minZoom: 0.1,
      maxZoom: 10,
      enableDamping: true,
      dampingFactor: 0.05,
      rotateSpeed: 1.0,
      panSpeed: 1.0,
      zoomSpeed: 1.0
    })

    // 添加鼠标事件监听
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      orbit.pointerdown(e);
    });
    canvas.addEventListener('pointermove', (e) => {
      e.preventDefault();
      orbit.pointermove(e);
    });
    canvas.addEventListener('pointerup', (e) => {
      e.preventDefault();
      orbit.pointerup();
    });
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      orbit.wheel(e);
    });

    // 键盘控制
    const moveSpeed = 0.1;
    const keysPressed = new Set();
    
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      keysPressed.add(key);
      
      // 单键功能
      switch(key) {
        case 'r': // 重置相机位置
          camera.position.copy(eye);
          target.copy(new Vector3(0, 6, -10));
          orbit.update();
          break;
        
        case 'l': // 切换光源可见性
          scene.children.forEach(obj => {
            if (obj.mat && obj.mat.programName === 'Emissive') {
              obj.visible = !obj.visible;
            }
          });
          break;
        
        case 'f': // 聚焦到房间中心
          target.set(0, 6, 0);
          orbit.update();
          break;
        
        case 'c': // 切换相机模式（正交/透视）
          if (camera instanceof PerspectiveCamera) {
            camera = new OrthographicCamera(
              -10 * aspect, 10 * aspect,
              10, -10,
              near, far
            );
          } else {
            camera = new PerspectiveCamera(fov, aspect, near, far);
          }
          camera.position.copy(eye);
          orbit.camera = camera;
          break;
        
        case 'h': // 显示/隐藏帮助信息
          showHelp();
          break;
      }
      
      // 组合键功能
      if (e.ctrlKey || e.metaKey) { // Ctrl/Cmd 键
        switch(key) {
          case '=': // 增加移动速度
          case '+':
            moveSpeed = Math.min(moveSpeed * 1.2, 2.0);
            break;
          
          case '-': // 减小移动速度
          case '_':
            moveSpeed = Math.max(moveSpeed * 0.8, 0.1);
            break;
        }
      }
    });
    
    window.addEventListener('keyup', (e) => {
      keysPressed.delete(e.key.toLowerCase());
    });
    
    // 相机移动函数
    function updateCameraPosition() {
      const { position } = camera;
      // 获取相机到目标点的方向作为前进方向
      const forward = target.clone().sub(position).normalize();
      // 计算右方向
      const right = forward.clone().cross(new Vector3(0, 1, 0)).normalize();
      
      let moved = false;
      // 前后移动
      if (keysPressed.has('w')) {
        const movement = forward.clone().multiplyScalar(moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      if (keysPressed.has('s')) {
        const movement = forward.clone().multiplyScalar(-moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      
      // 左右移动
      if (keysPressed.has('a')) {
        const movement = right.clone().multiplyScalar(-moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      if (keysPressed.has('d')) {
        const movement = right.clone().multiplyScalar(moveSpeed);
        position.add(movement);
        target.add(movement);
        moved = true;
      }
      
      // 上下移动
      if (keysPressed.has('q')) {
        position.y += moveSpeed;
        target.y += moveSpeed;
        moved = true;
      }
      if (keysPressed.has('e')) {
        position.y -= moveSpeed;
        target.y -= moveSpeed;
        moved = true;
      }
      
      if (moved) {
        orbit.update();
      }
    }

    // 定义光源
    let lights = [
      // 主光源 - 顶部中央偏前
      new Light(
        new Vector3(0, 9.5, -3),
        [400, 400, 400]  // 降低光源强度
      )
    ]
    
    // 光照数据
    const lightData = {
      u_LightPositions: {
        value: lights.map(light => [...light.position]).flat(),
        type: 'uniform3fv',
      },
      u_LightColors: {
        value: lights.map(light => [...light.color]).flat(),
        type: 'uniform3fv',
      }
    }
    // 材质数据
    const matData = {
      u_Kd: {
        value: [0.9, 0.9, 0.9],
        type: 'uniform3fv',
      },
      u_Ks: {
        value: [0.4, 0.4, 0.4],
        type: 'uniform3fv',
      },
      u_Ka: {
        value: [0.4, 0.4, 0.4],
        type: 'uniform3fv',
      },
    }
    // 相机数据
    const cameraData = {
      u_PvMatrix: {
        value: orbit.getPvMatrix().elements,
        type: 'uniformMatrix4fv',
      },
      u_Eye: {
        value: Object.values(camera.position),
        type: 'uniform3fv',
      },
    }

    // 景
    const scene = new Scene3D({ gl })

    // 等待景初始化完成后再创建对象
    async function initScene() {
      // 检查WebGL上下文
      if (!gl) {
        console.error('Unable to initialize WebGL. Your browser may not support it.');
        return;
      }

      // 等待场景准备就绪
      await new Promise(resolve => {
        const checkReady = () => {
          if (scene.ready) {
            resolve();
          } else {
            setTimeout(checkReady, 100);
          }
        };
        checkReady();
      });

      // 为每个光源创建可视化对象
      lights.forEach(light => {
        const visualizer = light.createVisualizer();
        if (visualizer) {
          scene.add(visualizer);
        }
      });

      // 创建光照数据
      const lightPositions = [];
      const lightColors = [];
      lights.forEach(light => {
        lightPositions.push(...light.position);
        lightColors.push(...light.color.map(x => x/800));
      });

      // 基础光照数据
      const lightData = {
        u_LightPositions: {
          value: lightPositions,
          type: 'uniform3fv'
        },
        u_LightColors: {
          value: lightColors,
          type: 'uniform3fv'
        }
      };

      // 相机数据
      const cameraData = {
        u_Eye: {
          value: Object.values(camera.position),
          type: 'uniform3fv'
        },
        u_PvMatrix: {
          value: orbit.getPvMatrix().elements,
          type: 'uniformMatrix4fv'
        }
      };

      // 基础材质数据
      const matData = {
        u_ModelMatrix: {
          value: new Matrix4().elements,
          type: 'uniformMatrix4fv'
        }
      };

      // 基础材质
      const basicMaterial = {
        program: 'Main',
        programName: 'Main',
        data: {
          ...matData,
          ...lightData,
          ...cameraData
        }
      };

      // 创建房间
      const room = new Room(20, 12, 20)
      scene.add(new Obj3D({
        geo: new Geo({
          data: {
            a_Position: {
              array: new Float32Array(room.vertices),
              size: 3
            },
            a_Normal: {
              array: new Float32Array(room.normals),
              size: 3
            },
            a_TexCoord: {
              array: new Float32Array(room.texCoords),
              size: 2
            },
            a_TextureType: {
              array: new Float32Array(room.textureTypes),
              size: 1
            }
          },
          index: {
            array: new Uint16Array(room.indexes)
          }
        }),
        mat: new Mat({
          program: 'Main',
          programName: 'Main',
          data: {
            ...basicMaterial.data,
            u_ModelMatrix: {
              value: new Matrix4().elements,
              type: 'uniformMatrix4fv'
            },
            u_WallTex: {
              value: 0,  // 墙壁使用纹理单元0
              type: 'uniform1i'
            },
            u_FloorTex: {
              value: 1,  // 地板使用纹理单元1
              type: 'uniform1i'
            }
          },
          mode: 'TRIANGLES'
        })
      }))

      // 创建玻璃球
      const glassSphere = new Sphere(1.2, 32, 32)
      scene.add(new Obj3D({
        geo: new Geo({
          data: {
            a_Position: {
              array: new Float32Array(glassSphere.vertices),
              size: 3
            },
            a_Normal: {
              array: new Float32Array(glassSphere.normals),
              size: 3
            }
          },
          index: {
            array: new Uint16Array(glassSphere.indexes)
          }
        }),
        mat: new Mat({
          program: 'Glass',
          programName: 'Glass',
          data: {
            ...basicMaterial.data,
            u_ModelMatrix: {
              value: new Matrix4().setPosition(4, 1.2, 4).elements,
              type: 'uniformMatrix4fv'
            },
            u_NormalMatrix: {
              value: new Matrix4()
                .makeTranslation(4, 1.2, 4)
                .invert()
                .transpose()
                .elements,
              type: 'uniformMatrix4fv'
            }
          }
        })
      }))

      // 添加光源可视化
      lights.forEach(light => {
        scene.add(light.createVisualizer({
          gl,
          camera: {
            getPvMatrix: () => orbit.getPvMatrix()
          }
        }));
      })

      // 加载纹理
      const [wallTex, floorTex] = await Promise.all([
          imgPromise('./textures/wall.jpg'),
          imgPromise('./textures/floor.jpg')
      ]);

      // 设置纹理参数
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
      
      // 创建墙壁纹理（纹理单元0）
      const wallTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, wallTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, wallTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      
      // 创建地板纹理（纹理单元1）
      const floorTexture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, floorTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, floorTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

      // 设置纹理
      const textureUniforms = {
          u_WallTex: {
              value: 0,  // 墙壁使用纹理单元0
              type: 'uniform1i'
          },
          u_FloorTex: {
              value: 1,  // 地板使用纹理单元1
              type: 'uniform1i'
          }
      };
      
      // 更新基础材质数据
      basicMaterial.data = {
          ...basicMaterial.data,
          ...textureUniforms
      };
      
      // 添加一些装饰性物体
      const decorations = [
        // 漂浮的金属环 - 移到房间左前方
        { 
          geometry: new Torus(0.8, 0.3, 32, 32),
          position: [-6, 5.5, -6],
          rotation: [Math.PI/4, 0, Math.PI/6],
          material: {
            metallic: 0.9,
            roughness: 0.2,
            color: [0.98, 0.8, 0.6], // 玫瑰金色
            useTexture: false
          },
          animation: {
            type: 'float',
            amplitude: 0.3,
            frequency: 1.2
          }
        },
        // 漂浮的水晶体（八面体）- 移到房间右后方
        {
          geometry: new Box(1.2, 1.2, 1.2),
          position: [7, 6.2, 6],
          rotation: [Math.PI/4, Math.PI/4, 0],
          material: {
            metallic: 0.3,
            roughness: 0.1,
            color: [0.4, 0.8, 1.0], // 蓝色水晶
            useTexture: false
          },
          animation: {
            type: 'rotate',
            speed: 0.01
          }
        },
        // 漂浮的发光球 - 移到房间右前方
        {
          geometry: new Sphere(0.6, 32, 32),
          position: [6, 4.8, -7],
          material: {
            metallic: 0.0,
            roughness: 0.0,
            color: [1.0, 0.6, 0.2], // 橙色
            useTexture: false
          },
          animation: {
            type: 'pulse',
            frequency: 1.5
          }
        },
        // 漂浮的金属立方体 - 移到房间左后方
        {
          geometry: new Box(0.9, 0.9, 0.9),
          position: [-7, 7, 7],
          rotation: [0, Math.PI/6, Math.PI/6],
          material: {
            metallic: 1.0,
            roughness: 0.1,
            color: [0.7, 0.7, 0.8], // 银色
            useTexture: false
          },
          animation: {
            type: 'float',
            amplitude: 0.4,
            frequency: 0.8
          }
        }
      ];

      // 添加装饰物
      decorations.forEach(({ geometry, position, rotation = [0,0,0], material, animation }) => {
        const modelMatrix = new Matrix4()
          .setPosition(...position)
          .multiply(
            new Matrix4().makeRotationX(rotation[0])
              .multiply(new Matrix4().makeRotationY(rotation[1]))
              .multiply(new Matrix4().makeRotationZ(rotation[2]))
          );

        const obj = new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(geometry.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(geometry.normals),
                size: 3
              },
              a_TextureType: {
                array: new Float32Array(geometry.vertices.length / 3).fill(2.0),  // 使用纯色
                size: 1
              }
            },
            index: {
              array: new Uint16Array(geometry.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              u_ModelMatrix: {
                value: modelMatrix.elements,
                type: 'uniformMatrix4fv'
              },
              u_Color: {
                value: material.color,
                type: 'uniform3fv'
              },
              u_Metallic: {
                value: material.metallic,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: material.roughness,
                type: 'uniform1f'
              },
              u_Eye: {
                value: Object.values(camera.position),
                type: 'uniform3fv'
              },
              u_LightPositions: {
                value: lightPositions,
                type: 'uniform3fv'
              },
              u_LightColors: {
                value: lightColors,
                type: 'uniform3fv'
              },
              u_PvMatrix: {
                value: orbit.getPvMatrix().elements,
                type: 'uniformMatrix4fv'
              }
            },
            mode: 'TRIANGLES'
          })
        });

        // 存储动画相关信息
        if (animation) {
          animatedObjects.push({
            object: obj,
            animation,
            basePosition: [...position],
            baseRotation: [...rotation],
            modelMatrix,
            material
          });
        }

        scene.add(obj);
      });

      // 创建吊灯
      function createCeilingLamp(position, color) {
        const lampGroup = [];
        
        // 灯罩（圆锥体）
        const lampShade = new Cone(0.6, 0.2, 1.2, 32);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lampShade.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(lampShade.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lampShade.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...position)
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.1,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.9, 0.9, 0.9],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 发光体
        const lightBulb = new Sphere(0.2, 16, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lightBulb.vertices),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lightBulb.indexes)
            }
          }),
          mat: new Mat({
            program: 'Emissive',
            programName: 'Emissive',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(position[0], position[1] - 0.2, position[2])
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_EmissiveColor: {
                value: color.map(c => c/800),
                type: 'uniform3fv'
              },
              u_Intensity: {
                value: 2.0,
                type: 'uniform1f'
              }
            }
          })
        }));

        return lampGroup;
      }

      // 创建壁灯
      function createWallLamp(position, rotation, color) {
        const lampGroup = [];
        
        // 灯臂
        const arm = new Cylinder(0.05, 0.05, 0.8, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(arm.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(arm.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(arm.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...position)
                  .multiply(
                    new Matrix4().makeRotationX(rotation[0])
                      .multiply(new Matrix4().makeRotationY(rotation[1]))
                      .multiply(new Matrix4().makeRotationZ(rotation[2]))
                      )
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.2,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.8, 0.8, 0.8],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 灯罩（半球形）
        const shade = new HemiSphere(0.3, 16, 16);
        const shadePosition = [
          position[0] + Math.sin(rotation[1]) * 0.8,
          position[1],
          position[2] + Math.cos(rotation[1]) * 0.8
        ];
        
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(shade.vertices),
                size: 3
              },
              a_Normal: {
                array: new Float32Array(shade.normals),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(shade.indexes)
            }
          }),
          mat: new Mat({
            program: 'Main',
            programName: 'Main',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...shadePosition)
                  .multiply(
                    new Matrix4().makeRotationY(rotation[1] + Math.PI/2)
                  )
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_Metallic: {
                value: 0.9,
                type: 'uniform1f'
              },
              u_Roughness: {
                value: 0.1,
                type: 'uniform1f'
              },
              u_Color: {
                value: [0.9, 0.9, 0.9],
                type: 'uniform3fv'
              }
            }
          })
        }));

        // 发光体
        const lightBulb = new Sphere(0.15, 16, 16);
        lampGroup.push(new Obj3D({
          geo: new Geo({
            data: {
              a_Position: {
                array: new Float32Array(lightBulb.vertices),
                size: 3
              }
            },
            index: {
              array: new Uint16Array(lightBulb.indexes)
            }
          }),
          mat: new Mat({
            program: 'Emissive',
            programName: 'Emissive',
            data: {
              ...basicMaterial.data,
              u_ModelMatrix: {
                value: new Matrix4()
                  .setPosition(...shadePosition)
                  .elements,
                type: 'uniformMatrix4fv'
              },
              u_EmissiveColor: {
                value: color.map(c => c/800),
                type: 'uniform3fv'
              },
              u_Intensity: {
                value: 1.5,
                type: 'uniform1f'
              }
            }
          })
        }));

        return lampGroup;
      }

      // 创建并添加灯具
      const lamps = [
        // 中央吊灯
        ...createCeilingLamp([0, 9.5, -3], [400, 400, 400]),  // 降低吊灯强度
        
        // 装饰性壁灯（不产生实际光照）
        ...createWallLamp([-9.5, 8, 0], [0, Math.PI/2, 0], [100, 75, 50]),
        ...createWallLamp([9.5, 8, 0], [0, -Math.PI/2, 0], [50, 75, 100]),
        ...createWallLamp([0, 8, -9.5], [0, 0, 0], [75, 75, 75])
      ];

      lamps.forEach(lamp => scene.add(lamp));

      // 开始动画
      animate();
    }

    // 启动场景初始化
    initScene().catch(error => {
      console.error('Scene initialization failed:', error);
    });

    // 渲染循环
    function animate() {
        if (!scene.ready) {
            requestAnimationFrame(animate);
            return;
        }
        
        // 更新时间
        time += 0.016;
        
        // 更新相机位置
        updateCameraPosition();
        
        // ���新轨道控制器
        orbit.update();

        // 更新光照数据
        const lightPositions = [];
        const lightColors = [];
        lights.forEach(light => {
            lightPositions.push(...light.position);
            lightColors.push(...light.color.map(x => x/800));
        });

        // 更新动画物体
        animatedObjects.forEach(({ object, animation, basePosition, baseRotation, modelMatrix, material }) => {
          switch (animation.type) {
            case 'float':
              // 上下漂浮动画
              const floatOffset = Math.sin(time * animation.frequency) * animation.amplitude;
              modelMatrix.setPosition(
                basePosition[0],
                basePosition[1] + floatOffset,
                basePosition[2]
              );
              break;
            
            case 'rotate':
              // 自转动画 - 使用初始旋转角度加上时间增量
              modelMatrix
                .setPosition(...basePosition)
                .multiply(
                  new Matrix4()
                    .makeRotationX(baseRotation[0])
                    .multiply(new Matrix4().makeRotationY(baseRotation[1] + time * animation.speed))
                    .multiply(new Matrix4().makeRotationZ(baseRotation[2]))
                );
              break;
            
            case 'pulse':
              // 脉冲发光动画
              const intensity = 1 + Math.sin(time * animation.frequency) * 0.3;
              object.mat.data.u_Color.value = material.color.map(c => c * intensity);
              break;
          }
          
          // 更新模型矩阵
          object.mat.data.u_ModelMatrix.value = modelMatrix.elements;
        });

        // 渲染主场景
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        // 更新场景中所有对象的材质数据
        scene.children.forEach(obj => {
            if (obj.mat) {
                const data = {
                    u_PvMatrix: {
                        value: orbit.getPvMatrix().elements,
                        type: 'uniformMatrix4fv'
                    },
                    u_Eye: {
                        value: Object.values(camera.position),
                        type: 'uniform3fv'
                    },
                    u_LightPositions: {
                        value: lightPositions,
                        type: 'uniform3fv'
                    },
                    u_LightColors: {
                        value: lightColors,
                        type: 'uniform3fv'
                    }
                };
                Object.assign(obj.mat.data, data);
            }
        });
        
        scene.draw();
        
        requestAnimationFrame(animate);
    }

    // 添加帮助信息显示功能
    function showHelp() {
      const helpText = `
键控制说明：
  移动：
    W/S - 前进/后退
    A/D - 左右移动
    Q/E - 上升/下降
    
  功能键：
    R - 重置相机位置
    L - 切换光源可见性
    F - 聚焦到房间中心
    C - 切换相机模式
    H - 显示/隐藏帮助
    
  速度控制���
    Ctrl/Cmd + '+' - 增加移动速度
    Ctrl/Cmd + '-' - 减小移动速度
    
  鼠标控制：
    左键拖动 - 旋转视角
    右键拖动 - 平移视角
    滚轮 - 缩放
`;

      // 创建或更新帮助面板
      let helpPanel = document.getElementById('helpPanel');
      if (!helpPanel) {
        helpPanel = document.createElement('div');
        helpPanel.id = 'helpPanel';
        helpPanel.style.cssText = `
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 15px 20px;
          border-radius: 10px;
          font-family: monospace;
          white-space: pre;
          pointer-events: none;
          transition: opacity 0.3s;
          z-index: 1000;
          font-size: 14px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.3);
          border: 1px solid rgba(255,255,255,0.1);
        `;
        document.body.appendChild(helpPanel);
      }
      
      helpPanel.textContent = helpText;
      
      // 切换显示状态
      const currentDisplay = helpPanel.style.opacity;
      helpPanel.style.opacity = currentDisplay === '0' ? '1' : '0';
    }

    // 在初始化时显示帮助信息
    window.addEventListener('load', showHelp);

    // 创���阴影贴图
    const SHADOW_MAP_SIZE = 2048;
    const shadowFramebuffer = gl.createFramebuffer();
    const shadowTexture = gl.createTexture();
    
    // 初始化阴影贴图纹理
    gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA,
      SHADOW_MAP_SIZE, SHADOW_MAP_SIZE,
      0, gl.RGBA, gl.UNSIGNED_BYTE, null
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    // 创建深度缓冲区
    const depthBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
    gl.renderbufferStorage(
      gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
      SHADOW_MAP_SIZE, SHADOW_MAP_SIZE
    );
    
    // 配置帧缓冲区
    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFramebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D, shadowTexture, 0
    );
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
      gl.RENDERBUFFER, depthBuffer
    );
    
    // 检查帧缓冲状态
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      console.error('Framebuffer is not complete:', status);
    }
    
    // 置绑定
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  </script>
</body>

</html>
